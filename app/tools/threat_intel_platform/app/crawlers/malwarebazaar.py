import requests
import csv
import io
from datetime import datetime, timedelta
import logging
from app.models.ioc import IOC, FeedRun
from app import db

logger = logging.getLogger(__name__)

class MalwareBazaarCrawler:
    """Crawler for Abuse.ch MalwareBazaar"""
    
    BASE_URL = "https://bazaar.abuse.ch"
    CSV_EXPORT_URL = "https://bazaar.abuse.ch/export/csv/recent/"
    
    def __init__(self):
        """Initialize MalwareBazaar crawler"""
        self.headers = {
            'User-Agent': 'FlexGenThreatIntel/1.0'
        }
    
    def fetch_recent_samples(self):
        """
        Fetch recent samples from MalwareBazaar CSV export
        
        Returns:
            List of sample dictionaries
        """
        response = requests.get(self.CSV_EXPORT_URL, headers=self.headers)
        
        if response.status_code != 200:
            logger.error(f"Failed to fetch MalwareBazaar export: {response.status_code}")
            return []
        
        # Parse CSV data
        csv_data = response.text
        samples = []
        
        # Skip comments at the beginning (lines starting with #)
        csv_lines = []
        for line in csv_data.splitlines():
            if not line.startswith('#'):
                csv_lines.append(line)
        
        if not csv_lines:
            logger.warning("No valid CSV data found in MalwareBazaar export")
            return []
        
        # Parse CSV
        csv_content = '\n'.join(csv_lines)
        csv_file = io.StringIO(csv_content)
        csv_reader = csv.DictReader(csv_file)
        
        for row in csv_reader:
            samples.append(row)
        
        return samples
    
    def process_samples(self, samples):
        """
        Process samples and store in database
        
        Args:
            samples: List of sample dictionaries from MalwareBazaar
            
        Returns:
            Tuple of (processed count, new count)
        """
        processed_count = 0
        new_count = 0
        
        for sample in samples:
            try:
                # Extract relevant fields
                sha256_hash = sample.get('sha256_hash', '').strip()
                if not sha256_hash:
                    continue
                
                md5_hash = sample.get('md5_hash', '').strip()
                sha1_hash = sample.get('sha1_hash', '').strip()
                
                # Extract tags
                tags = []
                
                # Add malware family tag
                malware_family = sample.get('signature')
                if malware_family:
                    tags.append(f"malware:{malware_family}")
                
                # Add tags
                sample_tags = sample.get('tags')
                if sample_tags:
                    for tag in sample_tags.split(','):
                        tag = tag.strip()
                        if tag:
                            tags.append(tag)
                
                # Get first/last seen dates
                first_seen = None
                try:
                    first_seen_str = sample.get('first_seen')
                    if first_seen_str:
                        first_seen = datetime.strptime(first_seen_str, '%Y-%m-%d %H:%M:%S')
                except ValueError:
                    pass
                
                # Calculate confidence based on data quality
                confidence = 0.7  # Base confidence for MalwareBazaar
                if malware_family:
                    confidence += 0.1
                if len(tags) > 2:
                    confidence += 0.1
                
                # Create metadata
                metadata = {
                    'malware_family': malware_family,
                    'file_type': sample.get('file_type'),
                    'file_size': sample.get('file_size'),
                    'reporter': sample.get('reporter'),
                    'delivery_method': sample.get('delivery_method')
                }
                
                # Add the SHA256 hash
                self._add_or_update_ioc('sha256', sha256_hash, tags, confidence, first_seen, metadata)
                new_count += 1
                
                # Add MD5 hash if available
                if md5_hash:
                    self._add_or_update_ioc('md5', md5_hash, tags, confidence, first_seen, metadata)
                
                # Add SHA1 hash if available
                if sha1_hash:
                    self._add_or_update_ioc('sha1', sha1_hash, tags, confidence, first_seen, metadata)
                
                processed_count += 1
                
            except Exception as e:
                logger.error(f"Error processing MalwareBazaar sample: {str(e)}")
                continue
        
        return processed_count, new_count
    
    def _add_or_update_ioc(self, ioc_type, value, tags, confidence, first_seen, metadata):
        """Helper method to add or update an IOC in the database"""
        # Check if IOC already exists
        existing_ioc = IOC.query.filter_by(type=ioc_type, value=value).first()
        
        if existing_ioc:
            # Update last_seen and possibly tags
            existing_ioc.last_seen = datetime.utcnow()
            
            # Update tags if new ones available
            current_tags = set(existing_ioc.tags) if existing_ioc.tags else set()
            new_tags = set(tags)
            combined_tags = list(current_tags.union(new_tags))
            existing_ioc.tags = combined_tags
            
            # Update confidence if higher
            if confidence > existing_ioc.confidence:
                existing_ioc.confidence = confidence
                
            # Update metadata
            if existing_ioc.metadata:
                existing_ioc.metadata.update(metadata)
            else:
                existing_ioc.metadata = metadata
            
            db.session.add(existing_ioc)
        else:
            # Create new IOC
            source_url = f"https://bazaar.abuse.ch/browse.php"
            
            new_ioc = IOC(
                type=ioc_type,
                value=value,
                source='Abuse.ch MalwareBazaar',
                source_url=source_url,
                confidence=confidence,
                tags=tags,
                context=f"Malware hash from MalwareBazaar ({metadata.get('malware_family', 'unknown')})",
                metadata=metadata
            )
            
            # Set first_seen if available
            if first_seen:
                new_ioc.first_seen = first_seen
                
            db.session.add(new_ioc)
    
    def run(self):
        """
        Main method to run the crawler
        
        Returns:
            Dictionary with crawl statistics
        """
        # Create a FeedRun record
        feed_run = FeedRun(
            feed_name='Abuse.ch MalwareBazaar',
            status='running'
        )
        db.session.add(feed_run)
        db.session.commit()
        
        try:
            # Fetch recent samples
            samples = self.fetch_recent_samples()
            
            # Process samples
            processed_count, new_count = self.process_samples(samples)
            
            # Commit changes
            db.session.commit()
            
            # Update FeedRun with results
            feed_run.end_time = datetime.utcnow()
            feed_run.status = 'success'
            feed_run.items_processed = processed_count
            feed_run.items_added = new_count
            db.session.add(feed_run)
            db.session.commit()
            
            return {
                'status': 'success',
                'samples_processed': processed_count,
                'items_added': new_count
            }
            
        except Exception as e:
            # Log the error and update FeedRun
            logger.error(f"Error in MalwareBazaar crawler: {str(e)}")
            
            feed_run.end_time = datetime.utcnow()
            feed_run.status = 'failed'
            feed_run.error_message = str(e)
            db.session.add(feed_run)
            db.session.commit()
            
            return {
                'status': 'failed',
                'error': str(e)
            } 