import { NextRequest, NextResponse } from "next/server";

// Define types for request and response
interface ScanRequest {
	url: string;
	scanMode: "lightweight" | "comprehensive";
}

interface Vulnerability {
	id: string;
	name: string;
	type: string;
	description: string;
	severity: "Critical" | "High" | "Medium" | "Low" | "Info";
	details: Record<string, any>;
	remediation: string;
}

interface ScanResponse {
	target_url: string;
	scan_time: string;
	scan_duration: string;
	scan_mode: "lightweight" | "comprehensive";
	vulnerabilities: Vulnerability[];
	statistics: {
		critical_count: number;
		high_count: number;
		medium_count: number;
		low_count: number;
		info_count: number;
		total_requests: number;
		scan_coverage_percent: number;
	};
	tech_stack: string[];
	dom_xss_results?: Record<string, any>;
	ssrf_ssti_results?: Record<string, any>;
	spa_analysis?: Record<string, any>;
	summary?: string;
}

export async function POST(request: NextRequest): Promise<NextResponse> {
	try {
		// Parse request body
		const body: ScanRequest = await request.json();
		const { url, scanMode } = body;

		// Validate request
		if (!url) {
			return NextResponse.json({ error: "URL is required" }, { status: 400 });
		}

		if (!scanMode || !["lightweight", "comprehensive"].includes(scanMode)) {
			return NextResponse.json(
				{ error: "Valid scan mode is required (lightweight or comprehensive)" },
				{ status: 400 }
			);
		}

		// In a real implementation, this would initiate an actual scan
		// For now, we'll generate a mock response
		const scanResult = generateMockScanResult(url, scanMode);

		return NextResponse.json(scanResult);
	} catch (error) {
		console.error("Error processing scan request:", error);
		return NextResponse.json(
			{ error: "Internal server error" },
			{ status: 500 }
		);
	}
}

function generateMockScanResult(
	url: string,
	mode: "lightweight" | "comprehensive"
): ScanResponse {
	// Common vulnerabilities for both modes
	const commonVulnerabilities: Vulnerability[] = [
		{
			id: "vuln-1",
			name: "Missing Security Headers",
			type: "Security Misconfiguration",
			description:
				"The application is missing several recommended security headers that help protect against common web vulnerabilities.",
			severity: "Medium",
			details: {
				missing_headers: [
					"Content-Security-Policy",
					"X-Content-Type-Options",
					"X-Frame-Options",
				],
			},
			remediation:
				"Implement all recommended security headers including Content-Security-Policy, X-Content-Type-Options, and X-Frame-Options.",
		},
		{
			id: "vuln-2",
			name: "Insecure Cookie Configuration",
			type: "Security Misconfiguration",
			description:
				"Cookies are being set without secure and httpOnly flags, making them vulnerable to theft via XSS attacks.",
			severity: "Medium",
			details: {
				cookies: [
					{
						name: "session",
						secure: false,
						httpOnly: false,
					},
				],
			},
			remediation:
				"Set the secure and httpOnly flags on all sensitive cookies to protect them from client-side access and man-in-the-middle attacks.",
		},
		{
			id: "vuln-3",
			name: "Version Disclosure",
			type: "Information Disclosure",
			description:
				"Application is revealing version information in HTTP headers which can help attackers identify vulnerable components.",
			severity: "Low",
			details: {
				revealed_information: [
					"Server: Apache/2.4.41",
					"X-Powered-By: PHP/7.4.3",
				],
			},
			remediation:
				"Configure web server and application framework to not disclose version information in HTTP headers.",
		},
	];

	// Complex vulnerabilities for comprehensive mode only
	const comprehensiveVulnerabilities: Vulnerability[] = [
		{
			id: "vuln-4",
			name: "DOM-based Cross-Site Scripting (XSS)",
			type: "XSS",
			description:
				"User input from the URL hash fragment is used directly in innerHTML without proper sanitization, allowing execution of arbitrary JavaScript.",
			severity: "High",
			details: {
				vulnerable_code:
					"document.getElementById('userContent').innerHTML = location.hash.substring(1);",
				location: "main.js:42",
				proof_of_concept: "https://example.com/#<img src=x onerror=alert(1)>",
			},
			remediation:
				"Use textContent instead of innerHTML when dealing with user input, or implement proper input sanitization with a library like DOMPurify.",
		},
		{
			id: "vuln-5",
			name: "Server-Side Template Injection (SSTI)",
			type: "Injection",
			description:
				"The application's template engine evaluates user input as part of a template, allowing for potential remote code execution.",
			severity: "Critical",
			details: {
				vulnerable_parameter: "template",
				endpoint: "/api/render",
				proof_of_concept: "{{7*7}}",
			},
			remediation:
				"Never allow user-supplied data to be used in template contexts. Use a sandboxed template environment and implement strict input validation.",
		},
		{
			id: "vuln-6",
			name: "Cross-Site Request Forgery (CSRF)",
			type: "CSRF",
			description:
				"Sensitive operations do not require a CSRF token, allowing attackers to trick users into performing actions without their knowledge.",
			severity: "High",
			details: {
				vulnerable_endpoints: ["/api/user/settings", "/api/payment/update"],
				authentication: "Session Cookie only",
			},
			remediation:
				"Implement CSRF tokens for all state-changing operations and validate them on the server-side.",
		},
		{
			id: "vuln-7",
			name: "Server-Side Request Forgery (SSRF)",
			type: "SSRF",
			description:
				"The application fetches remote resources based on user-supplied URLs without proper validation, potentially allowing access to internal systems.",
			severity: "High",
			details: {
				vulnerable_parameter: "url",
				endpoint: "/api/fetch-resource",
				impact: "Potential access to internal systems and services",
			},
			remediation:
				"Implement a whitelist of allowed domains and protocols, and validate all URLs against this list before making requests.",
		},
	];

	// Generate tech stack based on the URL
	const generateTechStack = (url: string) => {
		const techOptions = [
			["React", "Redux", "Next.js", "Vercel"],
			["Angular", "TypeScript", "Bootstrap", "Firebase"],
			["Vue.js", "Vuex", "Nuxt.js", "Netlify"],
			["Express", "Node.js", "MongoDB", "AWS Lambda"],
			["Django", "Python", "PostgreSQL", "Nginx"],
			["Laravel", "PHP", "MySQL", "Apache"],
			["Ruby on Rails", "Ruby", "Redis", "Heroku"],
		];

		// Use URL as seed to select a tech stack
		const seed = url
			.split("")
			.reduce((acc, char) => acc + char.charCodeAt(0), 0);
		const selectedStack = techOptions[seed % techOptions.length];

		// Add common techs
		return [...selectedStack, "Webpack", "Git", "jQuery"];
	};

	// Generate statistics based on mode and vulnerabilities
	const calculateStatistics = (
		vulnerabilities: Vulnerability[],
		mode: string
	) => {
		const counts = {
			critical_count: vulnerabilities.filter((v) => v.severity === "Critical")
				.length,
			high_count: vulnerabilities.filter((v) => v.severity === "High").length,
			medium_count: vulnerabilities.filter((v) => v.severity === "Medium")
				.length,
			low_count: vulnerabilities.filter((v) => v.severity === "Low").length,
			info_count: vulnerabilities.filter((v) => v.severity === "Info").length,
		};

		// Add some info items for comprehensive mode
		if (mode === "comprehensive") {
			counts.info_count += 3;
		}

		return {
			...counts,
			total_requests: mode === "comprehensive" ? 248 : 87,
			scan_coverage_percent: mode === "comprehensive" ? 92 : 65,
		};
	};

	// Generate summary based on findings
	const generateSummary = (vulnerabilities: Vulnerability[]) => {
		const critical = vulnerabilities.filter(
			(v) => v.severity === "Critical"
		).length;
		const high = vulnerabilities.filter((v) => v.severity === "High").length;

		if (critical > 0) {
			return `The scan detected ${critical} critical vulnerability and ${high} high-risk issues that require immediate attention. These vulnerabilities could potentially allow an attacker to gain unauthorized access or execute code on the system. We recommend addressing these issues as soon as possible to mitigate the risk of a security breach.`;
		} else if (high > 0) {
			return `The scan detected ${high} high-risk vulnerability that should be addressed promptly. While no critical issues were found, the identified vulnerabilities still present significant security risks that could be exploited by attackers.`;
		} else {
			return `The scan completed successfully with no critical or high-risk vulnerabilities detected. Several medium and low-risk issues were identified that should be addressed as part of ongoing security maintenance, but they don't represent an immediate security threat.`;
		}
	};

	// Determine which vulnerabilities to include based on scan mode
	const vulnerabilities =
		mode === "comprehensive"
			? [...commonVulnerabilities, ...comprehensiveVulnerabilities]
			: commonVulnerabilities;

	const techStack = generateTechStack(url);
	const statistics = calculateStatistics(vulnerabilities, mode);
	const summary = generateSummary(vulnerabilities);

	// Simulate scan duration
	const duration =
		mode === "comprehensive"
			? `${Math.floor(Math.random() * 10) + 14}m ${Math.floor(
					Math.random() * 60
			  )}s`
			: `${Math.floor(Math.random() * 5) + 5}m ${Math.floor(
					Math.random() * 60
			  )}s`;

	// Create response
	return {
		target_url: url,
		scan_time: new Date().toISOString(),
		scan_duration: duration,
		scan_mode: mode,
		vulnerabilities,
		statistics,
		tech_stack: techStack,
		summary,
		dom_xss_results:
			mode === "comprehensive"
				? {
						sinks_identified: 12,
						sources_analyzed: 8,
						vulnerable_patterns: [
							{
								sink: "innerHTML",
								source: "location.hash",
								context:
									"document.getElementById('userContent').innerHTML = location.hash.substring(1);",
							},
							{
								sink: "eval",
								source: "localStorage.getItem",
								context:
									"eval('var lastState = ' + localStorage.getItem('appState'));",
							},
						],
				  }
				: undefined,
		ssrf_ssti_results:
			mode === "comprehensive"
				? {
						tested_endpoints: 15,
						injectable_parameters: [
							{
								endpoint: "/api/render",
								parameter: "template",
								template_engine: "Suspected Handlebars or similar",
							},
							{
								endpoint: "/api/fetch-resource",
								parameter: "url",
								vulnerable_to: "SSRF",
							},
						],
				  }
				: undefined,
		spa_analysis:
			mode === "comprehensive"
				? {
						framework_detected: techStack.includes("React")
							? "React"
							: techStack.includes("Angular")
							? "Angular"
							: techStack.includes("Vue.js")
							? "Vue.js"
							: "Unknown",
						state_management: techStack.includes("Redux")
							? "Redux"
							: techStack.includes("Vuex")
							? "Vuex"
							: "Custom/Unknown",
						authentication_method: "JWT Token (stored in localStorage)",
						security_issues: [
							"Sensitive data found in localStorage",
							"Lack of proper state validation between views",
							"Insufficient protection against CSRF attacks",
						],
				  }
				: undefined,
	};
}
